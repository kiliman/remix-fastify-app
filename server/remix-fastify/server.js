/**
 * @remix-run/express v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict'

Object.defineProperty(exports, '__esModule', { value: true })

var stream = require('stream')
var serverRuntime = require('@remix-run/server-runtime')
var node = require('@remix-run/node')

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by Express middleware like `req.session`.
 */

/**
 * Returns a request handler for Express that serves the response using Remix.
 */
function createRequestHandler({
  build,
  getLoadContext,
  mode = process.env.NODE_ENV,
}) {
  let platform = {
    formatServerError: node.formatServerError,
  }
  let handleRequest = serverRuntime.createRequestHandler(build, platform, mode)
  return async (req, reply) => {
    try {
      let abortController = new node.AbortController()
      let request = createRemixRequest(req, abortController)
      let loadContext =
        typeof getLoadContext === 'function'
          ? getLoadContext(request, reply)
          : undefined
      let response = await handleRequest(request, loadContext)
      sendRemixResponse(reply, response, abortController)
    } catch (error) {
      // Express doesn't support async functions, so we have to pass along the
      // error manually using next().
      reply.send(error)
    }
  }
}
function createRemixHeaders(requestHeaders) {
  let headers = new node.Headers()

  for (let [key, values] of Object.entries(requestHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (const value of values) {
          headers.append(key, value)
        }
      } else {
        headers.set(key, values)
      }
    }
  }

  return headers
}
function createRemixRequest(req, abortController) {
  let origin = `${req.protocol}://${req.hostname}`
  let url = new URL(req.url, origin)
  let init = {
    method: req.method,
    headers: createRemixHeaders(req.headers),
    signal:
      abortController === null || abortController === void 0
        ? void 0
        : abortController.signal,
    abortController,
  }

  if (req.method !== 'GET' && req.method !== 'HEAD') {
    init.body = req.raw.pipe(
      new stream.PassThrough({
        highWaterMark: 16384,
      }),
    )
  }

  return new node.Request(url.href, init)
}

function sendRemixResponse(reply, response, abortController) {
  var _response$body

  reply.code(response.status)

  for (let [key, values] of Object.entries(response.headers.raw())) {
    for (const value of values) {
      reply.header(key, value)
    }
  }

  if (abortController.signal.aborted) {
    reply.header('Connection', 'close')
  }

  if (Buffer.isBuffer(response.body)) {
    reply.send(response.body)
  } else if (
    (_response$body = response.body) !== null &&
    _response$body !== void 0 &&
    _response$body.pipe
  ) {
    response.body.pipe(reply)
  } else {
    reply.send()
  }
}

exports.createRemixHeaders = createRemixHeaders
exports.createRemixRequest = createRemixRequest
exports.createRequestHandler = createRequestHandler
